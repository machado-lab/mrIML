#'mrPdP:  Wrapper to plot mutlti-response model agnostic partial dependency plots. 
#.
#'@param yhats A \code{list} is the list generated by mrIMLpredicts
#'@param X A \code{dataframe} is a response variable data set (species, OTUs, SNPs etc)
#'@param Y  A \code{dataframe} #is the feature dataset
#'@param Model 1 A \code{list} can be any model from the tidy model package. See examples.
#'@param 'Feature' \code{character} Feature from the Y set to plot the partial dependency.
#'
#'@details The aim of this function is to enable users to calculate partial dependencies for the response variables for each model (i.e. species/SNPs)
#' and then use plot_mrpd (a plotting function) to create a pd plot for all species/SNPs for each feature. 
#' Could build functionality for ICE plots but that would be messy for multiple repsonse variables.
#' 
#' @example 
#' testPdp <- mrPdP(yhats, model1,X=X,Y=Y)


mrPdP <- function(yhats, X, Y, Feature=Feature){
  
  l_response<- length(yhats)
  n_features <- names(Y)
  n_response <- names(X)
  
  #unpack everything from yhats
  dList <- yhats %>% purrr::map(pluck('data')) #get together training data.
  modList <- yhats %>% purrr::map(pluck('mod1_k'))
  #testList <- yhats %>% purrr::map(pluck('data_testa')) could be useful
  modList <- yhats %>% purrr::map(pluck('mod1_k'))
  workflow_partial_mr <- NULL #create empty dataframe for pd values
  
  pdp_pred_fun <- function(object, newdata) { #pd funtion
   predict(object, newdata, type = "prob")$.pred_1 #predict positive class. couldn't get colMeans to work. Werid results for the FIV dataset
  }
  
  for (i in 1:l_response){ 
    
    
    # testing:
    #pdp_pred_fun(modList[[i]], testList[[i]])
    
    workflow_partial <-
      partial(modList[[i]],
              pred.var = paste0(Feature),
              pred.fun = pdp_pred_fun,
              grid.resolution = 15, #this may improve things for the bobcat FIV data
              train = dList[[i]])
    response.id <- rep(names(X[i]), nrow(workflow_partial)) #add names to the new dataframe.Problem here in the loop
    
    workflow_partial_mr[[i]] <- cbind(workflow_partial , response.id)
  }
  
  PdpGlobal <- as.data.frame(do.call(rbind, workflow_partial_mr))
  
  #plot - could be a sepparate function
  pdPlot <- ggplot(PdpGlobal, aes_string(Feature, 'yhat', color='response.id'))+
    geom_line() +
    theme_bw()+
    theme(legend.title = element_blank())+
    geom_smooth(method='loess')
  print(pdPlot)
  
 readline(prompt="All responses plot. Press [enter] to continue to the global summary plot")
 
  turnover <-PdpGlobal %>% 
    dplyr:: group_by_at(paste(Feature)) %>%  #this doesn't work right and leads to an error. Im sure there is a simple fix.
    #dplyr::group_by(scale.prop.zos) %>% 
    dplyr::summarise(avgYhat = mean(yhat))
  
  GlobalPD <- ggplot(turnover, aes_string(Feature, 'avgYhat'))+
    geom_line(size=1.2, color='red') +
    theme_bw()+
    geom_smooth(method='loess')
  print( GlobalPD)
  
  return(PdpGlobal)
}























